# -*- coding: utf-8 -*-
"""Product Dataset Analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bA96dbUcjWf8ta_lBdRaf_SSDxo7zn5P
"""

from google.colab import files
uploades = files.upload()

import pandas as pd
df = pd.read_csv('electronics_products_pricing.csv')

df

def convert_to_pounds(weight_str):
    if 'pounds' in weight_str:
        # Extract numeric value
        weight_value = float(weight_str.split()[0])
        return weight_value
    elif 'ounces' in weight_str:
        # Convert ounces to pounds (1 pound = 16 ounces)
        weight_value = float(weight_str.split()[0]) / 16
        return weight_value
    else:
        return None  # Handle other units or invalid values

df['weight_in_pounds'] = df['weight'].apply(convert_to_pounds)

df

price_stats = df['price'].describe()
weight_stats = df['weight_in_pounds'].describe()

# Median (50th percentile) for 'price' and 'weight_in_pounds'
price_median = df['price'].median()
weight_median = df['weight_in_pounds'].median()

# Standard deviation for 'price' and 'weight_in_pounds'
price_std = df['price'].std()
weight_std = df['weight_in_pounds'].std()

# Quartiles for 'price' and 'weight_in_pounds'
price_quartiles = np.percentile(df['price'], [25, 50, 75])
weight_quartiles = np.percentile(df['weight_in_pounds'], [25, 50, 75])

# Print the results
print("Summary Statistics for Price:")
print(price_stats)
print(f"Median (50th percentile) for Price: {price_median}")
print(f"Standard Deviation for Price: {price_std}")
print(f"Quartiles for Price (25th, 50th, 75th percentiles): {price_quartiles}\n")

print("Summary Statistics for Weight (in pounds):")
print(weight_stats)
print(f"Median (50th percentile) for Weight (in pounds): {weight_median}")
print(f"Standard Deviation for Weight (in pounds): {weight_std}")
print(f"Quartiles for Weight (in pounds) (25th, 50th, 75th percentiles): {weight_quartiles}")

import matplotlib.pyplot as plt
import seaborn as sns

# Create subplots for multiple visualizations
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 10))
plt.subplots_adjust(wspace=0.5)

# Histogram for 'price'
axes[0, 0].hist(df['price'], bins=20, color='skyblue', edgecolor='black')
axes[0, 0].set_title('Price Distribution')
axes[0, 0].set_xlabel('Price')
axes[0, 0].set_ylabel('Frequency')

# Box plot for 'price'
sns.boxplot(data=df, y='price', ax=axes[0, 1], color='lightgreen')
axes[0, 1].set_title('Price Box Plot')
axes[0, 1].set_ylabel('Price')

# Scatter plot between 'price' and 'weight_in_pounds'
sns.scatterplot(data=df, x='weight_in_pounds', y='price', ax=axes[1, 0], color='orange')
axes[1, 0].set_title('Price vs. Weight')
axes[1, 0].set_xlabel('Weight (in pounds)')
axes[1, 0].set_ylabel('Price')

# Bar chart for 'prices.condition'
sns.countplot(data=df, x='prices.condition', ax=axes[1, 1], palette='Set2')
axes[1, 1].set_title('Count of Products by Condition')
axes[1, 1].set_xlabel('Condition')
axes[1, 1].set_ylabel('Count')

# Show the plots
plt.tight_layout()
plt.show()

df['categories'] = df['categories'].str.split(',')

unique_categories = []

# Iterate through each row to collect unique categories
for categories_list in df['categories']:
    unique_categories.extend(categories_list)

# Remove leading and trailing whitespaces from category names
unique_categories = [category.strip() for category in unique_categories]

# Count the frequency of each category
category_counts = pd.Series(unique_categories).value_counts()

# Plot a bar chart to visualize category distribution
import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))
sns.barplot(x=category_counts.values, y=category_counts.index, palette='viridis')
plt.title('Distribution of Products by Category')
plt.xlabel('Count')
plt.ylabel('Category')
plt.show()

# Print the top N categories with the highest counts
top_n = 10  # You can change this number to display more or fewer categories
print(f"Top {top_n} Categories by Count:")
print(category_counts.head(top_n))

for categories_list in df['categories']:
    unique_categories.extend(categories_list)

# Remove leading and trailing whitespaces from category names
unique_categories = [category.strip() for category in unique_categories]

# Count the frequency of each category
category_counts = pd.Series(unique_categories).value_counts()

# Select the top 10 categories
top_10_categories = category_counts.head(10)

# Plot a bar chart for the top 10 categories
plt.figure(figsize=(10, 6))
sns.barplot(x=top_10_categories.values, y=top_10_categories.index, palette='viridis')
plt.title('Top 10 Categories by Count')
plt.xlabel('Count')
plt.ylabel('Category')
plt.show()

fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 10))
plt.subplots_adjust(wspace=0.5)

# Histogram for 'price'
axes[0, 0].hist(df['price'], bins=20, color='skyblue', edgecolor='black')
axes[0, 0].set_title('Price Distribution')
axes[0, 0].set_xlabel('Price')
axes[0, 0].set_ylabel('Frequency')

# Box plot for 'price'
sns.boxplot(data=df, y='price', ax=axes[0, 1], color='lightgreen')
axes[0, 1].set_title('Price Box Plot')
axes[0, 1].set_ylabel('Price')

# Box plot for 'prices.condition' vs. 'price'
sns.boxplot(data=df, x='prices.condition', y='price', ax=axes[1, 0], palette='Set2')
axes[1, 0].set_title('Price vs. Condition')
axes[1, 0].set_xlabel('Condition')
axes[1, 0].set_ylabel('Price')

# Box plot for 'prices.isSale' vs. 'price'
sns.boxplot(data=df, x='prices.isSale', y='price', ax=axes[1, 1], palette='Set3')
axes[1, 1].set_title('Price vs. Sale Status')
axes[1, 1].set_xlabel('Is Sale')
axes[1, 1].set_ylabel('Price')

# Show the plots
plt.tight_layout()
plt.show()

"""Here are the key findings and insights from the price analysis based on the visualizations:

Price Distribution:

The price distribution is right-skewed, with most products having lower prices, and a few products with higher prices. This suggests that the majority of products are relatively affordable.
Price vs. Condition:

Products in different conditions have varying price distributions:
New products tend to have a higher median price compared to other conditions, indicating that new products are generally priced higher.
Refurbished products have a wider price range, including both lower-priced and higher-priced items.
Used products typically have a lower median price compared to new and refurbished items. However, there is a wide range of prices for used products, including some outliers with higher prices.
Price vs. Sale Status:

Products on sale (prices.isSale = True) generally have lower median prices compared to products that are not on sale (prices.isSale = False).
Products on sale also have a wider price range, with some products on sale being significantly cheaper, while others have prices comparable to non-sale items.
Key Takeaways:

New products tend to be priced higher, reflecting their condition and potentially higher perceived value.
Refurbished products have a broader price range, indicating variability in pricing for these items.
Used products are generally more affordable than new and refurbished items, but their prices can vary widely.
Products on sale attract budget-conscious consumers with lower prices, but the range of discounts varies among products.
These findings can help businesses make informed pricing decisions, especially in terms of how they price new, refurbished, and used products, and how they use sales and discounts to attract customers.
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Assuming you have the dataset loaded into a DataFrame named 'df'
# If not, you can load it from your data source.

# Selecting the numerical columns for correlation analysis
numerical_columns = ['price', 'weight_in_pounds']

# Creating a subset DataFrame with numerical columns
numerical_df = df[numerical_columns]

# Calculate the correlation matrix
correlation_matrix = numerical_df.corr()

# Create a heatmap to visualize correlations
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", square=True)
plt.title('Correlation Heatmap')
plt.show()

# Count the number of products per merchant
merchant_counts = df['prices.merchant'].value_counts()

# Select the top 10 merchants
top_10_merchants = merchant_counts.head(10)

# Plot a bar chart to visualize the distribution by top 10 merchants
plt.figure(figsize=(12, 6))
top_10_merchants.plot(kind='bar', color='skyblue')
plt.title('Top 10 Merchants by Number of Products')
plt.xlabel('Merchant')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

brand_counts = df['brand'].value_counts()

# Plot a bar chart to visualize the distribution by brands (top N brands)
top_n_brands = 10  # You can change this number to display more or fewer brands
plt.figure(figsize=(12, 6))
brand_counts.head(top_n_brands).plot(kind='bar', color='lightgreen')
plt.title(f'Distribution of Products by Top {top_n_brands} Brands')
plt.xlabel('Brand')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

categories_list = [category for sublist in df['categories'] for category in sublist]

# Count the number of products per category
category_counts = pd.Series(categories_list).value_counts()

# Plot a bar chart to visualize the distribution by categories (top N categories)
top_n_categories = 10  # You can change this number to display more or fewer categories
plt.figure(figsize=(12, 6))
category_counts.head(top_n_categories).plot(kind='bar', color='purple')
plt.title(f'Distribution of Products by Top {top_n_categories} Categories')
plt.xlabel('Category')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

"""Price Range Analysis:

Segment products into price ranges (e.g., low, medium, high) and analyze the distribution of products in each range.
Calculate the average, median, and standard deviation of prices within each category.
"""

low_price_threshold = 50
high_price_threshold = 200

# Step 2: Create Price Range Categories
def categorize_price(price):
    if price < low_price_threshold:
        return 'Low'
    elif price < high_price_threshold:
        return 'Medium'
    else:
        return 'High'

# Apply the categorization function to create a new column 'price_range'
df['price_range'] = df['price'].apply(categorize_price)

# Step 3: Analyze the Distribution of Products in Each Range
price_range_counts = df['price_range'].value_counts()

# Step 4: Calculate Average, Median, and Standard Deviation
price_stats = df.groupby('price_range')['price'].agg(['mean', 'median', 'std'])

# Display the results
print("Distribution of Products in Each Price Range:")
print(price_range_counts)

print("\nAverage, Median, and Standard Deviation of Prices in Each Price Range:")
print(price_stats)

"""Based on the distribution of products in each price range and the statistics for each price range, here are key findings and insights:

Distribution of Products in Each Price Range:

High Price Range: There are 2,561 products in the high price range, indicating a significant number of products with prices above the high price threshold.
Medium Price Range: The medium price range contains 2,162 products, making it the second most populated price range.
Low Price Range: There are 713 products in the low price range, suggesting that there are fewer products with prices below the low price threshold.
Average, Median, and Standard Deviation of Prices in Each Price Range:
4. High Price Range:

Average Price: $939.32
Median Price: $499.99
Standard Deviation: $936.07
Insight: The high price range has a wide price distribution with a high average and median price. The standard deviation is relatively high, indicating price variability within this range.
Medium Price Range:

Average Price: $115.53
Median Price: $104.99
Standard Deviation: $45.54
Insight: The medium price range has a lower average and median price compared to the high price range. The standard deviation suggests moderate price variability.
Low Price Range:

Average Price: $34.02
Median Price: $34.99
Standard Deviation: $11.40
Insight: The low price range has the lowest average and median prices among the price ranges, with the least price variability as indicated by the low standard deviation.
Key Insights:

The majority of products fall into the "High" and "Medium" price ranges, indicating a significant presence of products with prices above the low price threshold.
Products in the "High" price range have the widest price distribution and the highest average price, suggesting the presence of both expensive and premium-priced items.
Products in the "Low" price range have the narrowest price distribution and the lowest average price, indicating affordability and budget-friendly options.
Products in the "Medium" price range fall between the other two ranges in terms of price, with moderate price variability.
These findings can be valuable for pricing strategy, product categorization, and understanding the market positioning of products within different price ranges.

Brand Analysis:

Analyze the distribution of products by different brands.
Calculate brand-specific statistics such as the average price and the number of products.
"""

# Assuming you have the dataset loaded into a DataFrame named 'df'
# If not, you can load it from your data source.

# Step 1: Analyze the Distribution of Products by Brands
brand_counts = df['brand'].value_counts()

# Step 2: Calculate Brand-Specific Statistics
brand_stats = df.groupby('brand').agg({'price': ['mean', 'count']})

# Rename columns for clarity
brand_stats.columns = ['average_price', 'number_of_products']

# Sort the brands by the number of products in descending order
brand_stats = brand_stats.sort_values(by='number_of_products', ascending=False)

# Display the results
print("Distribution of Products by Brands:")
print(brand_counts)

print("\nBrand-Specific Statistics (Top 10 Brands by Number of Products):")
print(brand_stats.head(10))

"""Based on the distribution of products by brands and brand-specific statistics, here are key findings and insights:

Distribution of Products by Brands:

Sony and Samsung Dominate: Sony and Samsung are the two most dominant brands in the dataset, with 578 and 565 products, respectively. This suggests a strong presence of electronic products from these two brands.

Wide Brand Variety: The dataset includes a diverse range of brands, with a total of 254 unique brands represented. While Sony and Samsung have the highest counts, many other brands are also present.

Brand-Specific Statistics (Top 10 Brands by Number of Products):
3. Sony's High Count: Sony has the highest number of products (578) among all brands, indicating a wide product portfolio.

Samsung's High Count: Samsung closely follows Sony with 565 products, showing a strong product presence in the dataset.

Apple's Premium Position: Apple, despite having fewer products (188), has a relatively high average price of $1050.33. This suggests that Apple products tend to be premium-priced.

Yamaha and Pioneer: Yamaha and Pioneer, with 183 and 137 products, respectively, are notable brands in the dataset. Their average prices are also in the moderate range, indicating a balance between product variety and pricing.

LG's High Average Price: LG, with 132 products, stands out with an average price of $2053.46, indicating that they offer high-value or premium products.

Logitech's Affordable Range: Logitech offers a wide range of products (82) at a relatively affordable average price of $112.71.

Lenovo and Kenwood: Lenovo and Kenwood, with 80 and 74 products, respectively, provide a variety of products at competitive price points.

SanDisk: SanDisk, with 74 products, is another notable brand. The average price is moderate, indicating a balance between variety and pricing.

Key Insights:

Sony and Samsung have a significant presence in the dataset, suggesting strong competition between these two brands in the electronic products market.
Apple maintains a premium pricing strategy, reflected in its high average price despite a smaller product count.
Brands like LG and Logitech offer products at both premium and affordable price points, catering to a wider range of customers.
Yamaha and Pioneer strike a balance between product variety and pricing.
The dataset contains a diverse set of brands, reflecting the variety and competitiveness of the electronics market.
These insights can inform marketing strategies, product positioning, and brand-specific market analysis for the products in the dataset.
"""